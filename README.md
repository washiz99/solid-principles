# SOLID原則

SOLID原則(ソリッド)とは、オブジェクト指向プログラミングにおける基本的な5つの原則の頭文字。5つの原則とは、以下の原則。


- 単一責任の原則 (Single responsibility principle)
    - 1つのクラス、モジュール、は1つだけの役割を提供して責任を持たなければならない
- 開放閉鎖の原則 (Open–closed principle)
    - クラス、モジュールは、拡張に対して開かれていなければならないが、変更に対しては閉じていなければならない
- リスコフの置換原則 (Liskov substitution principle)
    - サブクラスは、そのスーパークラスの代用ができなければならない
- インターフェイス分離の原則 (Interface segregation principle)
    - 汎用的な目的のインターフェイスが1つだけあるよりも、特定のクライアント向けのインターフェイスが多数あった方がよりよい
- 依存性逆転の原則 (Dependency inversion principle)
    - 具象(具体的な物)ではなく、抽象に依存しなければならない


## SOLID原則が必要な理由
メンテナンスしづらいコードをつくらないようにするため。
SOLID原則は、メンテナンスしづらいコードを作らないようにするために考え出されたソフトウェア開発のための基本的なきまりをまとめたもの。


## 単一責任の原則 (Single responsibility principle)
単一責任の原則は、「1つのクラス、モジュール、は1つだけの役割を提供して責任を持たなければならない」という原則。

「1つのクラス、モジュールは、たった1つのことだけを行うべき」ではなくて、実際には、ある1つのアクターに対しての単一責任のみとなるように、適切にクラスやモジュールを機能で分割するようにしましょうということ。

アクターとは、変更を要望する人たちのこと。

1のクラスに、役割が複数ある場合、各クラスが何なのか複雑化してしまう。
1つの役割に別の役割が複雑に依存してしまい、1つの役割の変更が別の役割に影響を与える可能性があり、保守性の低下を招く。

コードを改修するときには影響範囲の調査は必須、改修したら影響する箇所については、テストも必要。
単一原則を守っていれば、改修箇所、テストの箇所を最小限にすることができる。

### 単一責任の原則を守った場合、

- クラス、モジュールを分けることで、可読性が向上する
- 役割を分けることで、他のクラスから利用できやすくなり拡張性が向上する
- 改修時の影響を最小限にすることができ、保守性が向上する


## 開放閉鎖の原則 (Open–closed principle)
開放閉鎖の原則は、「クラス、モジュールは、拡張に対して開かれていなければならないが、変更に対しては閉じていなければならない」という原則。

仕様を追加するためのコード改修については、オープンであるべき。
不具合を修正するためのコード改修については、クローズドであるべき。

### クローズドとは？
何かしらバグがあるので、それを修正するケースがある。
このバグ修正によって、本来、このクラスや、モジュールが提供する機能や責任を変更してはいけいないということ。

### オープンとは？
アプリケーションの仕様追加する際は、コードを追加することで、機能を拡張するということ。


開放閉鎖の原則は、不具合修正をする場合は、クローズドであるべきで、仕様を追加する場合は、オープンであるべきという原則。また、クローズド、オープンできるような設計、コードにするべきということをいっている。


### 開放閉鎖の原則を守った場合、

- 機能拡張が容易になりソフトウェアの拡張性が向上する
- 機能拡張時にテストをする際に、拡張機能だけを実施すればよく、元のソースコードはテストをしなくてよいため、保守性も向上する


## リスコフの置換原則 (Liskov substitution principle)
リスコフの置換原則は、「サブクラスは、そのスーパークラスの代用ができなければならない」という原則。

S が T の派生型(Tは、Sを継承している)であれば、プログラム内で T 型のオブジェクトが使われている箇所は全て S 型のオブジェクトで置換可能。


この原則は、仕様を単純化しようということを守りましょうということを言っている。プログラマーは、T をプロパティやメソッドを知っていれば、S も使えるということです。S だけが使えるメソッドを作ってはいけないということです。


### リスコフの置換原則を守った場合、

- スーバークラスの仕様を理解していれば、それを継承したサブクラスの仕様をすべて確認せずに利用することができるため、拡張性、保守性が向上する。
- サブクラス、スーパークラス間で実行できるものと実行できないものがあると、サブクラスのコードを理解する必要がある。


## インターフェイス分離の原則 (Interface segregation principle)
インターフェイス分離の原則は、「汎用的な目的のインターフェイスが1つだけあるよりも、特定のクライアント向けのインターフェイスが多数あった方がよりよい」という原則。


インターフェース上に色々な機能をもたせるためにメソッドを追加することで、継承先が必要としないメソッドを実装しないといけなくならなくなるようなことをしないようにする。
そのためには、複数のインターフェースに分割して作成し、クラスは必要なインターフェースを継承するようにする。継承するインターフェースの持つメソッドは必要最小限のものになる。


### インターフェイス分離の原則を守った場合、

・インターフェースの継承先が必要なメソッドのみの実装とため、インターフェースの修正による、継承先のクラスの修正量が限定され保守性・拡張性が向上する


## 依存性逆転の原則 (Dependency inversion principle)
依存性逆転の原則は、「具象(具体的な物)ではなく、抽象に依存しなければならない」という原則

Plugin、DI(Dependency Injection )は、この原則を適用した仕組みの代表例。

### 依存性逆転の原則を守った場合、
- 低水準モジュールを継承したクラスを利用機能拡張が容易になる


